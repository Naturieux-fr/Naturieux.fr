name: Quality Gate

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  GO_VERSION: '1.22'
  # Quality Gate Thresholds
  MIN_COVERAGE: 70
  MAX_COMPLEXITY: 15
  MAX_DUPLICATES: 5
  MAX_CRITICAL_ISSUES: 0
  MAX_SECURITY_ISSUES: 0

permissions:
  contents: write
  pull-requests: write

jobs:
  quality-gate:
    name: Quality Gate Check
    runs-on: ubuntu-latest
    outputs:
      passed: ${{ steps.gate.outputs.passed }}
      coverage: ${{ steps.metrics.outputs.coverage }}
      lint_issues: ${{ steps.metrics.outputs.lint_issues }}
      security_issues: ${{ steps.metrics.outputs.security_issues }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download dependencies
        run: go mod download

      # Run all quality checks
      - name: Run tests with coverage
        run: |
          go test ./... -coverprofile=coverage.out -covermode=atomic -race 2>&1 | tee test-results.txt
          go tool cover -func=coverage.out > coverage-func.txt
          go tool cover -html=coverage.out -o coverage.html

      - name: Install analysis tools
        run: |
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          go install github.com/fzipp/gocyclo/cmd/gocyclo@latest
          go install github.com/mibk/dupl@latest

      - name: Run golangci-lint
        continue-on-error: true
        run: golangci-lint run --out-format=json > lint-report.json || true

      - name: Run security scan
        continue-on-error: true
        run: gosec -fmt=json -out=security-report.json ./... || true

      - name: Run complexity check
        continue-on-error: true
        run: gocyclo -over ${{ env.MAX_COMPLEXITY }} . > complexity-report.txt || true

      - name: Run duplication check
        continue-on-error: true
        run: dupl -t 50 -plumbing . > dupl-report.txt || true

      # Calculate metrics
      - name: Calculate metrics
        id: metrics
        run: |
          # Coverage
          COVERAGE=$(grep "total:" coverage-func.txt | awk '{print $3}' | sed 's/%//')
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT

          # Lint issues
          LINT_ISSUES=$(cat lint-report.json | jq '.Issues | length' 2>/dev/null || echo "0")
          echo "lint_issues=$LINT_ISSUES" >> $GITHUB_OUTPUT

          # Critical issues (errcheck, gosec from lint)
          CRITICAL=$(cat lint-report.json | jq '[.Issues[] | select(.FromLinter == "errcheck" or .FromLinter == "gosec")] | length' 2>/dev/null || echo "0")
          echo "critical_issues=$CRITICAL" >> $GITHUB_OUTPUT

          # Security issues
          SEC_ISSUES=$(cat security-report.json | jq '.Issues | length' 2>/dev/null || echo "0")
          SEC_HIGH=$(cat security-report.json | jq '[.Issues[] | select(.severity == "HIGH")] | length' 2>/dev/null || echo "0")
          echo "security_issues=$SEC_ISSUES" >> $GITHUB_OUTPUT
          echo "security_high=$SEC_HIGH" >> $GITHUB_OUTPUT

          # Complexity issues
          COMPLEXITY_ISSUES=$(wc -l < complexity-report.txt || echo "0")
          echo "complexity_issues=$COMPLEXITY_ISSUES" >> $GITHUB_OUTPUT

          # Duplicates
          DUPLICATES=$(wc -l < dupl-report.txt || echo "0")
          echo "duplicates=$DUPLICATES" >> $GITHUB_OUTPUT

      # Quality Gate Decision
      - name: Quality Gate
        id: gate
        run: |
          PASSED=true
          REASONS=""

          # Check coverage
          COVERAGE=${{ steps.metrics.outputs.coverage }}
          if (( $(echo "$COVERAGE < $MIN_COVERAGE" | bc -l) )); then
            PASSED=false
            REASONS="$REASONS\n- Coverage ($COVERAGE%) below threshold ($MIN_COVERAGE%)"
          fi

          # Check critical issues
          CRITICAL=${{ steps.metrics.outputs.critical_issues }}
          if [ "$CRITICAL" -gt "$MAX_CRITICAL_ISSUES" ]; then
            PASSED=false
            REASONS="$REASONS\n- $CRITICAL critical issues found (max: $MAX_CRITICAL_ISSUES)"
          fi

          # Check security issues
          SEC_HIGH=${{ steps.metrics.outputs.security_high }}
          if [ "$SEC_HIGH" -gt "$MAX_SECURITY_ISSUES" ]; then
            PASSED=false
            REASONS="$REASONS\n- $SEC_HIGH high-severity security issues (max: $MAX_SECURITY_ISSUES)"
          fi

          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "reasons<<EOF" >> $GITHUB_OUTPUT
          echo -e "$REASONS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          if [ "$PASSED" = "false" ]; then
            echo "::error::Quality Gate FAILED"
            echo -e "Reasons:$REASONS"
          else
            echo "::notice::Quality Gate PASSED"
          fi

      # Generate Quality Report
      - name: Generate quality report
        id: report
        run: |
          COVERAGE=${{ steps.metrics.outputs.coverage }}
          LINT=${{ steps.metrics.outputs.lint_issues }}
          CRITICAL=${{ steps.metrics.outputs.critical_issues }}
          SEC=${{ steps.metrics.outputs.security_issues }}
          COMPLEXITY=${{ steps.metrics.outputs.complexity_issues }}
          DUPL=${{ steps.metrics.outputs.duplicates }}
          PASSED=${{ steps.gate.outputs.passed }}

          # Determine status icons
          COV_ICON=$([[ $(echo "$COVERAGE >= $MIN_COVERAGE" | bc -l) -eq 1 ]] && echo "✅" || echo "❌")
          CRITICAL_ICON=$([[ "$CRITICAL" -le "$MAX_CRITICAL_ISSUES" ]] && echo "✅" || echo "❌")
          SEC_ICON=$([[ "$SEC" -eq 0 ]] && echo "✅" || echo "⚠️")
          GATE_ICON=$([[ "$PASSED" == "true" ]] && echo "✅ PASSED" || echo "❌ FAILED")

          cat << EOF > QUALITY_REPORT.md
          # Quality Report

          > Last updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          ## Quality Gate: $GATE_ICON

          | Metric | Value | Threshold | Status |
          |--------|-------|-----------|--------|
          | Test Coverage | ${COVERAGE}% | ≥ ${MIN_COVERAGE}% | $COV_ICON |
          | Critical Issues | $CRITICAL | ≤ $MAX_CRITICAL_ISSUES | $CRITICAL_ICON |
          | Security Issues | $SEC | = 0 | $SEC_ICON |
          | Lint Issues | $LINT | - | ℹ️ |
          | High Complexity | $COMPLEXITY | ≤ 10 | $([[ "$COMPLEXITY" -le 10 ]] && echo "✅" || echo "⚠️") |
          | Code Duplicates | $DUPL | ≤ $MAX_DUPLICATES | $([[ "$DUPL" -le "$MAX_DUPLICATES" ]] && echo "✅" || echo "⚠️") |

          ## Coverage by Package

          \`\`\`
          $(cat coverage-func.txt)
          \`\`\`

          ## Thresholds

          - **Minimum Coverage**: ${MIN_COVERAGE}%
          - **Max Critical Issues**: ${MAX_CRITICAL_ISSUES}
          - **Max Security Issues**: ${MAX_SECURITY_ISSUES}
          - **Max Cyclomatic Complexity**: ${MAX_COMPLEXITY}

          ---
          *Generated by Quality Gate workflow*
          EOF

          echo "Report generated"

      - name: Upload quality report
        uses: actions/upload-artifact@v4
        with:
          name: quality-report
          path: |
            QUALITY_REPORT.md
            coverage.html
            coverage-func.txt
            lint-report.json
            security-report.json

      # Update QUALITY_REPORT.md in repo (only on main)
      - name: Commit quality report
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add QUALITY_REPORT.md
          git diff --staged --quiet || git commit -m "docs: update quality report [skip ci]"
          git push || true

      # Comment on PR
      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('QUALITY_REPORT.md', 'utf8');

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Quality Gate')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: report
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: report
              });
            }

      # Fail if quality gate didn't pass
      - name: Check quality gate result
        if: steps.gate.outputs.passed == 'false'
        run: |
          echo "Quality Gate FAILED"
          echo "${{ steps.gate.outputs.reasons }}"
          exit 1

  # Generate coverage badge
  badge:
    name: Update Coverage Badge
    runs-on: ubuntu-latest
    needs: quality-gate
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create coverage badge
        uses: schneegans/dynamic-badges-action@v1.7.0
        with:
          auth: ${{ secrets.GIST_SECRET }}
          gistID: YOUR_GIST_ID
          filename: naturieux-coverage.json
          label: coverage
          message: ${{ needs.quality-gate.outputs.coverage }}%
          valColorRange: ${{ needs.quality-gate.outputs.coverage }}
          maxColorRange: 100
          minColorRange: 0
